// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import '../artifacts.dart';
import '../base/common.dart';
import '../base/error_handling_io.dart';
import '../base/file_system.dart';
import '../base/logger.dart';
import '../base/process.dart';
import '../base/template.dart';
import '../base/version.dart';
import '../build_info.dart';
import '../cache.dart';
import '../globals.dart' as globals;
import '../plugins.dart';
import '../project.dart';
import 'swift_packages.dart';

/// The name of the Swift package that's generated by the Flutter tool to add
/// dependencies on Flutter plugin swift packages.
const String kFlutterGeneratedPluginSwiftPackageName = 'FlutterGeneratedPluginSwiftPackage';

/// The name of the Swift pacakge that's generated by the Flutter tool to add
/// a dependency on the Flutter/FlutterMacOS framework.
const String kFlutterGeneratedFrameworkSwiftPackageName = 'FlutterFramework';

const String _devDependenciesConditionalTemplate = '''
// Dev Dependencies are only added on non-Release builds
if (mode != "Release") {
    package.dependencies.append(contentsOf: [
        {{packageDependencies}}
    ])
    package.targets[0].dependencies.append(contentsOf: [
        {{targetDependencies}}
    ])
}

''';

/// Swift Package Manager is a dependency management solution for iOS and macOS
/// applications.
///
/// See also:
///   * https://www.swift.org/documentation/package-manager/ - documentation on
///     Swift Package Manager.
///   * https://developer.apple.com/documentation/packagedescription/package -
///     documentation on Swift Package Manager manifest file, Package.swift.
class SwiftPackageManager {
  const SwiftPackageManager({
    required Artifacts artifacts,
    required FileSystem fileSystem,
    required TemplateRenderer templateRenderer,
    required Cache cache,
  }) : _artifacts = artifacts,
       _fileSystem = fileSystem,
       _cache = cache,
       _templateRenderer = templateRenderer;

  final Artifacts _artifacts;
  final FileSystem _fileSystem;
  final TemplateRenderer _templateRenderer;
  final Cache _cache;

  static const BuildMode _defaultBuildMode = BuildMode.debug;

  static String formattedBuildMode(BuildMode buildMode) => 'let mode = "${buildMode.properName}"';

  /// Gathers dependencies on plugins and the Flutter framework and creates a
  /// Swift package for FlutterGeneratedPluginSwiftPackage.
  Future<void> generateFlutterSwiftPackages(
    DarwinPlatform platform,
    XcodeBasedProject project,
    List<Plugin> plugins, {
    bool remoteFramework = false,
    Directory? symlinkDirectory,
  }) async {
    // Reset output file list is necessary
    if (project is MacOSProject &&
        project.outputFileList.existsSync() &&
        project.outputFileList.readAsStringSync().contains('FlutterMacOS')) {
      project.outputFileList.writeAsStringSync('');
    }

    final (
      List<SwiftPackagePackageDependency> packageDependencies,
      List<SwiftPackageTargetDependency> targetDependencies,
      List<SwiftPackagePackageDependency> devPackageDependencies,
      List<SwiftPackageTargetDependency> devTargetDependencies,
    ) = await createDependencies(
      platforms: <DarwinPlatform>[platform],
      plugins: plugins,
      project: project.parent,
      remoteFramework: remoteFramework,
      defaultBuildMode: _defaultBuildMode,
      packageDirectory: project.relativeSwiftPackagesDirectory,
      flutterPluginSwiftPackageDirectory: project.flutterPluginSwiftPackageDirectory,
    );

    String? devDependenciesTemplate;
    if (devPackageDependencies.isNotEmpty) {
      final String devPackageDependenciesString = devPackageDependencies
          .map((SwiftPackagePackageDependency dep) => dep.format())
          .join(',\n');
      final String devTargetDependenciesString = devTargetDependencies
          .map((SwiftPackageTargetDependency dep) => dep.format())
          .join(',\n');
      devDependenciesTemplate = globals.templateRenderer
          .renderString(_devDependenciesConditionalTemplate, <String, Object>{
            'packageDependencies': devPackageDependenciesString,
            'targetDependencies': devTargetDependenciesString,
          });
    }

    // Create FlutterGeneratedPluginSwiftPackage
    final SwiftPackage pluginsPackage = SwiftPackage(
      manifest: project.flutterPluginSwiftPackageManifest,
      name: kFlutterGeneratedPluginSwiftPackageName,
      platforms: <SwiftPackageSupportedPlatform>[platform.supportedPackagePlatform],
      products: <SwiftPackageProduct>[
        SwiftPackageProduct(
          name: kFlutterGeneratedPluginSwiftPackageName,
          targets: <String>[kFlutterGeneratedPluginSwiftPackageName],
          // FlutterGeneratedPluginSwiftPackage must be statically linked to ensure
          // any dynamic dependencies are linked to Runner and prevent undefined symbols.
          libraryType: SwiftPackageLibraryType.static,
        ),
      ],
      dependencies: packageDependencies,
      targets: <SwiftPackageTarget>[
        SwiftPackageTarget.defaultTarget(
          name: kFlutterGeneratedPluginSwiftPackageName,
          dependencies: targetDependencies,
        ),
      ],
      templateRenderer: _templateRenderer,
      swiftCodeBeforePackageDefinition: formattedBuildMode(_defaultBuildMode),
      swiftCodeAfterPackageDefinition: devDependenciesTemplate,
    );
    pluginsPackage.createSwiftPackage();
  }

  // Returns dependencies on plugins and Flutter framework for the [FlutterGeneratedPluginSwiftPackage].
  Future<
    (
      List<SwiftPackagePackageDependency>,
      List<SwiftPackageTargetDependency>,
      List<SwiftPackagePackageDependency>,
      List<SwiftPackageTargetDependency>,
    )
  >
  createDependencies({
    required List<DarwinPlatform> platforms,
    required List<Plugin> plugins,
    required FlutterProject project,
    required Directory packageDirectory,
    required BuildMode defaultBuildMode,
    required Directory flutterPluginSwiftPackageDirectory,
    List<BuildMode> buildModes = const <BuildMode>[
      BuildMode.debug,
      BuildMode.profile,
      BuildMode.release,
    ],
    Directory? frameworkSource,
    bool remoteFramework = false,
  }) async {
    //Packages/Debug | .packages/Debug
    final Directory buildModeDirectory = packageDirectory.childDirectory(
      defaultBuildMode.properName,
    );
    //Packages/Debug/FlutterFramework | .packages/Debug/FlutterFramework
    final Directory flutterFrameworkPackageDirectory = buildModeDirectory.childDirectory(
      kFlutterGeneratedFrameworkSwiftPackageName,
    );

    final List<Plugin> regularPlugins = plugins.where((Plugin p) => !p.isDevDependency).toList();
    final List<Plugin> devPlugins = plugins.where((Plugin p) => p.isDevDependency).toList();

    ErrorHandlingFileSystem.deleteIfExists(packageDirectory, recursive: true);
    packageDirectory.createSync(recursive: true);

    final (
      List<SwiftPackagePackageDependency> packageDependencies,
      List<SwiftPackageTargetDependency> targetDependencies,
    ) = _createPluginDependencies(
      platforms: platforms,
      plugins: regularPlugins,
      project: project,
      packageDirectory: packageDirectory,
      defaultBuildMode: defaultBuildMode,
      flutterPluginSwiftPackageDirectory: flutterPluginSwiftPackageDirectory,
      buildModes: buildModes,
    );
    final (
      List<SwiftPackagePackageDependency> devPackageDependencies,
      List<SwiftPackageTargetDependency> devTargetDependencies,
    ) = _createPluginDependencies(
      platforms: platforms,
      plugins: devPlugins,
      project: project,
      packageDirectory: packageDirectory,
      defaultBuildMode: defaultBuildMode,
      flutterPluginSwiftPackageDirectory: flutterPluginSwiftPackageDirectory,
      buildModes: buildModes,
    );

    // Create FlutterFramework Swift Package
    await createFlutterFrameworkSwiftPackage(
      platforms: platforms,
      remoteFramework: remoteFramework,
      packageDirectory: packageDirectory,
      buildModes: buildModes,
      frameworkSource: frameworkSource,
    );

    // Add Flutter framework Swift package dependency
    final (
      SwiftPackagePackageDependency flutterFrameworkPackageDependency,
      SwiftPackageTargetDependency flutterFrameworkTargetDependency,
    ) = _dependencyForFlutterFramework(
      flutterPluginSwiftPackageDirectory: flutterPluginSwiftPackageDirectory,
      flutterFrameworkPackageDirectory: flutterFrameworkPackageDirectory,
      defaultBuildMode: defaultBuildMode,
    );
    packageDependencies.add(flutterFrameworkPackageDependency);
    targetDependencies.add(flutterFrameworkTargetDependency);

    return (packageDependencies, targetDependencies, devPackageDependencies, devTargetDependencies);
  }

  (List<SwiftPackagePackageDependency>, List<SwiftPackageTargetDependency>)
  _createPluginDependencies({
    required List<DarwinPlatform> platforms,
    required List<Plugin> plugins,
    required FlutterProject project,
    required Directory packageDirectory,
    required BuildMode defaultBuildMode,
    required Directory flutterPluginSwiftPackageDirectory,
    required List<BuildMode> buildModes,
  }) {
    final Directory buildModeDirectory = packageDirectory.childDirectory(
      defaultBuildMode.properName,
    );
    // Get plugin Swift package dependencies
    _symlinkPlugins(
      platforms: platforms,
      plugins: plugins,
      project: project,
      packageDirectory: packageDirectory,
      buildModes: buildModes,
    );

    // Add plugin Swift package dependency
    final (
      List<SwiftPackagePackageDependency> packageDependencies,
      List<SwiftPackageTargetDependency> targetDependencies,
    ) = _dependenciesForPlugins(
      plugins: plugins,
      platforms: platforms,
      buildModeDirectory: buildModeDirectory,
      flutterPluginSwiftPackageDirectory: flutterPluginSwiftPackageDirectory,
      defaultBuildMode: defaultBuildMode,
    );

    return (packageDependencies, targetDependencies);
  }

  /// Returns Flutter framework dependencies for the FlutterGeneratedPluginSwiftPackage.
  /// Uses [kFlutterGeneratedFrameworkSwiftPackageName] Swift package located at
  /// [flutterFrameworkPackageDirectory]. Makes the path relative to the
  /// [flutterPluginSwiftPackageDirectory]. Also, replaces the [defaultBuildMode]
  /// with a Swift variable.
  (SwiftPackagePackageDependency, SwiftPackageTargetDependency) _dependencyForFlutterFramework({
    required Directory flutterFrameworkPackageDirectory,
    required Directory flutterPluginSwiftPackageDirectory,
    required BuildMode defaultBuildMode,
  }) {
    final String frameworkPackagePath = _fileSystem.path
        .relative(
          flutterFrameworkPackageDirectory.path,
          from: flutterPluginSwiftPackageDirectory.path,
        )
        .replaceFirst(defaultBuildMode.properName, r'\(mode)');

    return (
      SwiftPackagePackageDependency.local(
        packageName: kFlutterGeneratedFrameworkSwiftPackageName,
        localPath: frameworkPackagePath,
      ),
      SwiftPackageTargetDependency.product(
        name: 'Flutter',
        packageName: kFlutterGeneratedFrameworkSwiftPackageName,
      ),
    );
  }

  /// Creates a symlink for each plugin that supports SwiftPM for each [buildModes] within [packageDirectory].
  void _symlinkPlugins({
    required List<BuildMode> buildModes,
    required List<Plugin> plugins,
    required FlutterProject project,
    required List<DarwinPlatform> platforms,
    required Directory packageDirectory,
  }) {
    for (final BuildMode buildMode in buildModes) {
      final Directory buildModeDirectory = packageDirectory.childDirectory(buildMode.properName);
      buildModeDirectory.createSync(recursive: true);
      for (final DarwinPlatform platform in platforms) {
        for (final Plugin plugin in plugins) {
          final bool supportsSwiftPackageManager = plugin.supportsSwiftPackageManager(
            _fileSystem,
            platform.name,
          );
          final String? packagePath = plugin.pluginSwiftPackagePath(_fileSystem, platform.name);
          if (!supportsSwiftPackageManager || packagePath == null) {
            continue;
          }
          final Link pluginSymlink = buildModeDirectory.childLink(plugin.name);

          // When a plugin supports both iOS and macOS, it only needs to be symlinked once.
          if (pluginSymlink.existsSync()) {
            continue;
          }
          pluginSymlink.createSync(packagePath);
        }
      }
    }
  }

  /// Returns plugin dependencies for the FlutterGeneratedPluginSwiftPackage.
  /// Uses the plugin Swift packages symlinked in the [buildModeDirectory].
  /// Makes the path relative to the [flutterPluginSwiftPackageDirectory]. Also,
  /// replaces the [defaultBuildMode] with a Swift variable.
  (List<SwiftPackagePackageDependency>, List<SwiftPackageTargetDependency>)
  _dependenciesForPlugins({
    required List<Plugin> plugins,
    required List<DarwinPlatform> platforms,
    required Directory buildModeDirectory,
    required BuildMode defaultBuildMode,
    required Directory flutterPluginSwiftPackageDirectory,
  }) {
    final List<SwiftPackagePackageDependency> packageDependencies =
        <SwiftPackagePackageDependency>[];
    final List<SwiftPackageTargetDependency> targetDependencies = <SwiftPackageTargetDependency>[];

    final Map<String, Plugin> supportedPlugins = <String, Plugin>{};
    final Map<String, List<DarwinPlatform>> supportedPlatforms = <String, List<DarwinPlatform>>{};
    for (final Plugin plugin in plugins) {
      // Don't add the same plugin twice. The same plugin may be listed twice if it's a plugin that supports multiple platforms.
      if (supportedPlugins[plugin.name] != null) {
        continue;
      }
      for (final DarwinPlatform platform in platforms) {
        final bool supportsSwiftPackageManager = plugin.supportsSwiftPackageManager(
          _fileSystem,
          platform.name,
        );
        if (!supportsSwiftPackageManager) {
          continue;
        }
        supportedPlugins[plugin.name] = plugin;
        if (supportedPlatforms[plugin.name] == null) {
          supportedPlatforms[plugin.name] = <DarwinPlatform>[];
        }
        supportedPlatforms[plugin.name]!.add(platform);
      }
    }

    for (final String pluginName in supportedPlugins.keys) {
      final Plugin plugin = supportedPlugins[pluginName]!;
      String packagePath = buildModeDirectory.childLink(plugin.name).path;
      packagePath = _fileSystem.path.relative(
        packagePath,
        from: flutterPluginSwiftPackageDirectory.path,
      );
      packagePath = packagePath.replaceFirst(defaultBuildMode.properName, r'\(mode)');

      packageDependencies.add(
        SwiftPackagePackageDependency.local(packageName: plugin.name, localPath: packagePath),
      );

      // The target dependency product name is hyphen separated because it's
      // the dependency's library name, which Swift Package Manager will
      // automatically use as the CFBundleIdentifier if linked dynamically. The
      // CFBundleIdentifier cannot contain underscores.
      targetDependencies.add(
        SwiftPackageTargetDependency.product(
          name: plugin.name.replaceAll('_', '-'),
          packageName: plugin.name,
          platformCondition: <SwiftPackagePlatform>[
            ...supportedPlatforms[plugin.name]!.map((DarwinPlatform platform) {
              return platform.packagePlatform;
            }),
          ],
        ),
      );
    }
    return (packageDependencies, targetDependencies);
  }

  /// Create a Swift package called [kFlutterGeneratedFrameworkSwiftPackageName] for each [buildModes] in [packageDirectory] that vends the Flutter/FlutterMacOS framework as a binary target.
  ///
  /// If [remoteFramework] is true, use a url to the zip in the Swift Package instead of a symlinked framework.
  Future<void> createFlutterFrameworkSwiftPackage({
    required List<BuildMode> buildModes,
    required List<DarwinPlatform> platforms,
    required Directory packageDirectory,
    bool remoteFramework = false,
    Directory? frameworkSource,
  }) async {
    for (final BuildMode buildMode in buildModes) {
      final List<SwiftPackageTarget> binaryTargets = <SwiftPackageTarget>[];
      final List<SwiftPackageTargetDependency> dependencies = <SwiftPackageTargetDependency>[];
      final Directory buildModeDirectory = packageDirectory.childDirectory(buildMode.properName);
      final Directory flutterFrameworkPackageDirectory = buildModeDirectory.childDirectory(
        kFlutterGeneratedFrameworkSwiftPackageName,
      );

      for (final DarwinPlatform platform in platforms) {
        final String frameworkName = platform.frameworkName;
        if (remoteFramework) {
          binaryTargets.add(await _remoteFlutterFrameworkTarget(platform, buildMode));
        } else {
          await _symlinkFlutterFramework(
            buildMode: buildMode,
            platform: platform,
            buildModeDirectory: buildModeDirectory,
            frameworkName: frameworkName,
            frameworkSource: frameworkSource,
          );
        }
        binaryTargets.add(
          SwiftPackageTarget.binaryTarget(
            name: frameworkName,
            relativePath: '$frameworkName.xcframework',
          ),
        );
        dependencies.add(
          SwiftPackageTargetDependency.target(
            name: frameworkName,
            platformCondition: <SwiftPackagePlatform>[platform.packagePlatform],
          ),
        );
      }

      final SwiftPackage flutterFrameworkPackage = SwiftPackage(
        manifest: flutterFrameworkPackageDirectory.childFile('Package.swift'),
        name: 'Flutter',
        platforms: <SwiftPackageSupportedPlatform>[],
        products: <SwiftPackageProduct>[
          SwiftPackageProduct(
            name: 'Flutter',
            targets: <String>[kFlutterGeneratedFrameworkSwiftPackageName],
          ),
        ],
        dependencies: <SwiftPackagePackageDependency>[],
        targets: <SwiftPackageTarget>[
          SwiftPackageTarget.defaultTarget(
            name: kFlutterGeneratedFrameworkSwiftPackageName,
            dependencies: dependencies,
          ),
          ...binaryTargets,
        ],
        templateRenderer: _templateRenderer,
      );
      flutterFrameworkPackage.createSwiftPackage();
    }
  }

  /// Symlinks the Flutter/FlutterMacOS from [frameworkSource] if provided or from the engine artifact cache to [buildModeDirectory].
  Future<void> _symlinkFlutterFramework({
    required DarwinPlatform platform,
    required Directory buildModeDirectory,
    required String frameworkName,
    required BuildMode buildMode,
    Directory? frameworkSource,
  }) async {
    final String frameworkArtifactPath;
    if (frameworkSource != null) {
      // Symlink the Flutter framework from [frameworkSource].
      frameworkArtifactPath =
          frameworkSource
              .childDirectory(buildMode.properName)
              .childDirectory('$frameworkName.xcframework')
              .path;
    } else {
      // Symlink the Flutter framework from the engine cache.
      frameworkArtifactPath = _artifacts.getArtifactPath(
        platform.xcframeworkArtifact,
        platform: platform.targetPlatform,
        mode: buildMode,
      );
    }
    final Link frameworkLink = _fileSystem.link(
      buildModeDirectory
          .childDirectory(kFlutterGeneratedFrameworkSwiftPackageName)
          .childDirectory('$frameworkName.xcframework')
          .path,
    );
    frameworkLink.createSync(frameworkArtifactPath, recursive: true);
  }

  Future<SwiftPackageTarget> _remoteFlutterFrameworkTarget(
    DarwinPlatform platform,
    BuildMode mode,
  ) async {
    final Status status = globals.logger.startProgress(
      'Downloading Flutter framework to calculate checksum...',
    );

    final String artifactName = platform.artifactName;
    final String artifactZip = platform.artifactZip;

    final String artifactsMode =
        mode == BuildMode.debug ? artifactName : '$artifactName-${mode.cliName}';
    final String frameworkArtifactUrl =
        '${_cache.storageBaseUrl}/flutter_infra_release/flutter/${_cache.engineRevision}/$artifactsMode/$artifactZip';
    final Directory destination = globals.fs.systemTempDirectory.createTempSync(
      'flutter_framework.',
    );
    await _cache.downloadArtifact(
      Uri.parse(frameworkArtifactUrl),
      destination.childFile(artifactZip),
      status,
    );
    status.stop();

    final RunResult results = await globals.processUtils.run(<String>[
      'swift',
      'package',
      'compute-checksum',
      destination.childFile(artifactZip).path,
    ]);
    if (results.exitCode != 0) {
      throwToolExit('Failed to get checksum for Flutter framework: ${results.stderr}');
    }

    return SwiftPackageTarget.remoteBinaryTarget(
      name: platform.frameworkName,
      zipUrl: frameworkArtifactUrl,
      zipChecksum: results.stdout.trim(),
    );
  }

  /// If the project's IPHONEOS_DEPLOYMENT_TARGET/MACOSX_DEPLOYMENT_TARGET is
  /// higher than the FlutterGeneratedPluginSwiftPackage's default
  /// SupportedPlatform, increase the SupportedPlatform to match the project's
  /// deployment target.
  ///
  /// This is done for the use case of a plugin requiring a higher iOS/macOS
  /// version than FlutterGeneratedPluginSwiftPackage.
  ///
  /// Swift Package Manager emits an error if a dependency isn’t compatible
  /// with the top-level package’s deployment version. The deployment target of
  /// a package’s dependencies must be lower than or equal to the top-level
  /// package’s deployment target version for a particular platform.
  ///
  /// To still be able to use the plugin, the user can increase the Xcode
  /// project's iOS/macOS deployment target and this will then increase the
  /// deployment target for FlutterGeneratedPluginSwiftPackage.
  static void updateMinimumDeployment({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required String deploymentTarget,
  }) {
    final Version? projectDeploymentTargetVersion = Version.parse(deploymentTarget);
    final SwiftPackageSupportedPlatform defaultPlatform = platform.supportedPackagePlatform;
    final SwiftPackagePlatform packagePlatform = platform.packagePlatform;

    if (projectDeploymentTargetVersion == null ||
        projectDeploymentTargetVersion <= defaultPlatform.version ||
        !project.flutterPluginSwiftPackageManifest.existsSync()) {
      return;
    }

    final String manifestContents = project.flutterPluginSwiftPackageManifest.readAsStringSync();
    final String oldSupportedPlatform = defaultPlatform.format();
    final String newSupportedPlatform =
        SwiftPackageSupportedPlatform(
          platform: packagePlatform,
          version: projectDeploymentTargetVersion,
        ).format();

    project.flutterPluginSwiftPackageManifest.writeAsStringSync(
      manifestContents.replaceFirst(oldSupportedPlatform, newSupportedPlatform),
    );
  }

  static void updateBuildMode({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required BuildMode buildMode,
  }) {
    final String manifestContents = project.flutterPluginSwiftPackageManifest.readAsStringSync();
    final String oldBuildMode = formattedBuildMode(_defaultBuildMode);
    final String newSupportedPlatform = formattedBuildMode(buildMode);

    project.flutterPluginSwiftPackageManifest.writeAsStringSync(
      manifestContents.replaceFirst(oldBuildMode, newSupportedPlatform),
    );
  }
}

enum DarwinPlatform {
  ios(
    name: 'ios',
    frameworkName: 'Flutter',
    targetPlatform: TargetPlatform.ios,
    packagePlatform: SwiftPackagePlatform.ios,
    artifactName: 'ios',
    artifactZip: 'artifacts.zip',
    xcframeworkArtifact: Artifact.flutterXcframework,
    sdks: <DarwinSDK>[DarwinSDK.iphoneos, DarwinSDK.iphonesimulator],
  ),
  macos(
    name: 'macos',
    frameworkName: 'FlutterMacOS',
    targetPlatform: TargetPlatform.darwin,
    packagePlatform: SwiftPackagePlatform.macos,
    artifactName: 'darwin-x64',
    artifactZip: 'framework.zip',
    xcframeworkArtifact: Artifact.flutterMacOSXcframework,
    sdks: <DarwinSDK>[DarwinSDK.macos],
  );

  const DarwinPlatform({
    required this.name,
    required this.frameworkName,
    required this.targetPlatform,
    required this.packagePlatform,
    required this.artifactName,
    required this.artifactZip,
    required this.xcframeworkArtifact,
    required this.sdks,
  });

  final String name;
  final String frameworkName;
  final TargetPlatform targetPlatform;
  final SwiftPackagePlatform packagePlatform;
  final String artifactName;
  final String artifactZip;
  final Artifact xcframeworkArtifact;
  final List<DarwinSDK> sdks;

  Version deploymentTarget() {
    switch (this) {
      case DarwinPlatform.ios:
        return Version(13, 0, null);
      case DarwinPlatform.macos:
        return Version(10, 15, null);
    }
  }

  SwiftPackageSupportedPlatform get supportedPackagePlatform {
    return SwiftPackageSupportedPlatform(platform: packagePlatform, version: deploymentTarget());
  }

  XcodeBasedProject xcodeProject(FlutterProject project) {
    switch (this) {
      case DarwinPlatform.ios:
        return project.ios;
      case DarwinPlatform.macos:
        return project.macos;
    }
  }
}

enum DarwinSDK {
  iphoneos(name: 'iphoneos', sdkType: EnvironmentType.physical),
  iphonesimulator(name: 'iphonesimulator', sdkType: EnvironmentType.simulator),
  macos(name: 'macosx');

  const DarwinSDK({required this.name, this.sdkType});

  final String name;
  final EnvironmentType? sdkType;
}
