// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import '../artifacts.dart';
import '../base/error_handling_io.dart';
import '../base/file_system.dart';
import '../base/template.dart';
import '../base/version.dart';
import '../build_info.dart';
import '../plugins.dart';
import '../project.dart';
import 'swift_packages.dart';

/// The name of the Swift package that's generated by the Flutter tool to add
/// dependencies on Flutter plugin swift packages.
const String kFlutterGeneratedPluginSwiftPackageName = 'FlutterGeneratedPluginSwiftPackage';
const String kFlutterGeneratedFrameworkSwiftPackageName = 'FlutterFramework';

/// Swift Package Manager is a dependency management solution for iOS and macOS
/// applications.
///
/// See also:
///   * https://www.swift.org/documentation/package-manager/ - documentation on
///     Swift Package Manager.
///   * https://developer.apple.com/documentation/packagedescription/package -
///     documentation on Swift Package Manager manifest file, Package.swift.
class SwiftPackageManager {
  const SwiftPackageManager({
    required Artifacts artifacts,
    required FileSystem fileSystem,
    required TemplateRenderer templateRenderer,
  }) : _artifacts = artifacts,
       _fileSystem = fileSystem,
       _templateRenderer = templateRenderer;

  final Artifacts _artifacts;
  final FileSystem _fileSystem;
  final TemplateRenderer _templateRenderer;

  static const BuildMode defaultBuildMode = BuildMode.debug;

  static String formattedBuildMode(BuildMode buildMode) => 'let mode = "${buildMode.properName}"';

  Future<void> generatePluginsSwiftPackage({
    required List<Plugin> plugins,
    required XcodeBasedProject project,
    required DarwinPlatform platform,
  }) async {

    // Reset output file list is necessary
    if (project is MacOSProject &&
        project.outputFileList.existsSync() &&
        project.outputFileList.readAsStringSync().contains('FlutterMacOS')) {
      project.outputFileList.writeAsStringSync('');
    }

    _symlinkDependencies(platform: platform, plugins: plugins, project: project);

    final Directory symlinkDirectory = project.swiftPackageBuildModeDirectory(defaultBuildMode);

    // Create FlutterFramework Swift Package
    final String frameworkName = platform.frameworkName;
    _createFlutterFrameworkSwiftPackage(
      frameworkName: frameworkName,
      project: project,
      defaultBuildMode: defaultBuildMode,
    );

    // Get plugin dependencies
    final (
      List<SwiftPackagePackageDependency> packageDependencies,
      List<SwiftPackageTargetDependency> targetDependencies,
    ) = _dependenciesForPlugins(
      plugins: plugins,
      platform: platform,
      symlinkDirectory: symlinkDirectory,
      pathRelativeTo: project.flutterPluginSwiftPackageDirectory.path,
      defaultBuildMode: defaultBuildMode,
    );

    // Add Flutter framework dependency
    final (
      SwiftPackagePackageDependency flutterFrameworkPackageDependency,
      SwiftPackageTargetDependency flutterFrameworkTargetDependency,
    ) = _dependencyForFlutterFramework(project: project, defaultBuildMode: defaultBuildMode);
    packageDependencies.add(flutterFrameworkPackageDependency);
    targetDependencies.add(flutterFrameworkTargetDependency);

    // Create FlutterGeneratedPluginSwiftPackage
    final SwiftPackage pluginsPackage = SwiftPackage(
      manifest: project.flutterPluginSwiftPackageManifest,
      name: kFlutterGeneratedPluginSwiftPackageName,
      platforms: <SwiftPackageSupportedPlatform>[platform.supportedPackagePlatform],
      products: <SwiftPackageProduct>[
        SwiftPackageProduct(
          name: kFlutterGeneratedPluginSwiftPackageName,
          targets: <String>[kFlutterGeneratedPluginSwiftPackageName],
          // FlutterGeneratedPluginSwiftPackage must be statically linked to ensure
          // any dynamic dependencies are linked to Runner and prevent undefined symbols.
          libraryType: SwiftPackageLibraryType.static,
        ),
      ],
      dependencies: packageDependencies,
      targets: <SwiftPackageTarget>[
        SwiftPackageTarget.defaultTarget(
          name: kFlutterGeneratedPluginSwiftPackageName,
          dependencies: targetDependencies,
        ),
      ],
      templateRenderer: _templateRenderer,
      swiftCodeBeforePackageDefinition: formattedBuildMode(defaultBuildMode),
    );
    pluginsPackage.createSwiftPackage();
  }

  void _symlinkDependencies({
    required List<Plugin> plugins,
    required XcodeBasedProject project,
    required DarwinPlatform platform,
  }) {
    final List<BuildMode> buildModes = <BuildMode>[
      BuildMode.debug,
      BuildMode.profile,
      BuildMode.release,
    ];
    for (final BuildMode buildMode in buildModes) {
      // Clear and delete the build mode directory.
      final Directory symlinkDirectory = project.swiftPackageBuildModeDirectory(buildMode);
      ErrorHandlingFileSystem.deleteIfExists(symlinkDirectory, recursive: true);
      symlinkDirectory.createSync(recursive: true);

      // Symlink the Flutter framework
      final String frameworkArtifactPath = _artifacts.getArtifactPath(
        platform.xcframeworkArtifact,
        platform: platform.targetPlatform,
        mode: buildMode,
      );
      final Link frameworkLink = _fileSystem.link(
        symlinkDirectory
            .childDirectory(kFlutterGeneratedFrameworkSwiftPackageName)
            .childDirectory('${platform.frameworkName}.xcframework')
            .path,
      );
      frameworkLink.createSync(frameworkArtifactPath, recursive: true);

      // Symlink the plugins
      for (final Plugin plugin in plugins) {
        final bool supportsSwiftPackageManager = plugin.supportsSwiftPackageManager(
          _fileSystem,
          platform.name,
        );
        final String? packagePath = plugin.pluginSwiftPackagePath(_fileSystem, platform.name);
        if (!supportsSwiftPackageManager || packagePath == null) {
          continue;
        }

        final Link pluginSymlink = symlinkDirectory.childLink(plugin.name);
        pluginSymlink.createSync(packagePath);
      }
    }
  }

  void _createFlutterFrameworkSwiftPackage({
    required String frameworkName,
    required XcodeBasedProject project,
    required BuildMode defaultBuildMode,
  }) {
    final Directory flutterFrameworkPackageDirectory = project
        .swiftPackageFlutterFrameworkDirectory(defaultBuildMode);
    final SwiftPackage flutterFrameworkPackage = SwiftPackage(
      manifest: flutterFrameworkPackageDirectory.childFile('Package.swift'),
      name: 'Flutter',
      platforms: <SwiftPackageSupportedPlatform>[],
      products: <SwiftPackageProduct>[
        SwiftPackageProduct(
          name: 'Flutter',
          targets: <String>[kFlutterGeneratedFrameworkSwiftPackageName],
        ),
      ],
      dependencies: <SwiftPackagePackageDependency>[],
      targets: <SwiftPackageTarget>[
        SwiftPackageTarget.defaultTarget(
          name: kFlutterGeneratedFrameworkSwiftPackageName,
          dependencies: <SwiftPackageTargetDependency>[
            SwiftPackageTargetDependency.target(name: frameworkName),
          ],
        ),
        SwiftPackageTarget.binaryTarget(
          name: frameworkName,
          relativePath: '$frameworkName.xcframework',
        ),
      ],
      templateRenderer: _templateRenderer,
    );
    flutterFrameworkPackage.createSwiftPackage();
  }

  (List<SwiftPackagePackageDependency>, List<SwiftPackageTargetDependency>)
  _dependenciesForPlugins({
    required List<Plugin> plugins,
    required DarwinPlatform platform,
    required Directory symlinkDirectory,
    required BuildMode defaultBuildMode,
    required String pathRelativeTo,
  }) {
    final List<SwiftPackagePackageDependency> packageDependencies =
        <SwiftPackagePackageDependency>[];
    final List<SwiftPackageTargetDependency> targetDependencies = <SwiftPackageTargetDependency>[];

    for (final Plugin plugin in plugins) {
      final bool supportsSwiftPackageManager = plugin.supportsSwiftPackageManager(
        _fileSystem,
        platform.name,
      );
      if (!supportsSwiftPackageManager) {
        continue;
      }

      String packagePath = symlinkDirectory.childLink(plugin.name).path;
      packagePath = _fileSystem.path.relative(packagePath, from: pathRelativeTo);
      packagePath = packagePath.replaceFirst(defaultBuildMode.properName, r'\(mode)');

      packageDependencies.add(SwiftPackagePackageDependency(name: plugin.name, path: packagePath));

      // The target dependency product name is hyphen separated because it's
      // the dependency's library name, which Swift Package Manager will
      // automatically use as the CFBundleIdentifier if linked dynamically. The
      // CFBundleIdentifier cannot contain underscores.
      targetDependencies.add(
        SwiftPackageTargetDependency.product(
          name: plugin.name.replaceAll('_', '-'),
          packageName: plugin.name,
        ),
      );
    }
    return (packageDependencies, targetDependencies);
  }

  (SwiftPackagePackageDependency, SwiftPackageTargetDependency) _dependencyForFlutterFramework({
    required XcodeBasedProject project,
    required BuildMode defaultBuildMode,
  }) {
    final Directory flutterFrameworkPackageDirectory = project
        .swiftPackageFlutterFrameworkDirectory(defaultBuildMode);
    final String frameworkPackagePath = _fileSystem.path
        .relative(
          flutterFrameworkPackageDirectory.path,
          from: project.flutterPluginSwiftPackageDirectory.path,
        )
        .replaceFirst(defaultBuildMode.properName, r'\(mode)');

    return (
      SwiftPackagePackageDependency(
        name: kFlutterGeneratedFrameworkSwiftPackageName,
        path: frameworkPackagePath,
      ),
      SwiftPackageTargetDependency.product(
        name: 'Flutter',
        packageName: kFlutterGeneratedFrameworkSwiftPackageName,
      ),
    );
  }

  /// If the project's IPHONEOS_DEPLOYMENT_TARGET/MACOSX_DEPLOYMENT_TARGET is
  /// higher than the FlutterGeneratedPluginSwiftPackage's default
  /// SupportedPlatform, increase the SupportedPlatform to match the project's
  /// deployment target.
  ///
  /// This is done for the use case of a plugin requiring a higher iOS/macOS
  /// version than FlutterGeneratedPluginSwiftPackage.
  ///
  /// Swift Package Manager emits an error if a dependency isn’t compatible
  /// with the top-level package’s deployment version. The deployment target of
  /// a package’s dependencies must be lower than or equal to the top-level
  /// package’s deployment target version for a particular platform.
  ///
  /// To still be able to use the plugin, the user can increase the Xcode
  /// project's iOS/macOS deployment target and this will then increase the
  /// deployment target for FlutterGeneratedPluginSwiftPackage.
  static void updateMinimumDeployment({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required String deploymentTarget,
  }) {
    final Version? projectDeploymentTargetVersion = Version.parse(deploymentTarget);
    final SwiftPackageSupportedPlatform defaultPlatform = platform.supportedPackagePlatform;
    final SwiftPackagePlatform packagePlatform = platform.packagePlatform;

    if (projectDeploymentTargetVersion == null ||
        projectDeploymentTargetVersion <= defaultPlatform.version ||
        !project.flutterPluginSwiftPackageManifest.existsSync()) {
      return;
    }

    final String manifestContents = project.flutterPluginSwiftPackageManifest.readAsStringSync();
    final String oldSupportedPlatform = defaultPlatform.format();
    final String newSupportedPlatform =
        SwiftPackageSupportedPlatform(
          platform: packagePlatform,
          version: projectDeploymentTargetVersion,
        ).format();

    project.flutterPluginSwiftPackageManifest.writeAsStringSync(
      manifestContents.replaceFirst(oldSupportedPlatform, newSupportedPlatform),
    );
  }

  static void updateBuildMode({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required BuildMode buildMode,
  }) {
    final String manifestContents = project.flutterPluginSwiftPackageManifest.readAsStringSync();
    final String oldBuildMode = formattedBuildMode(defaultBuildMode);
    final String newSupportedPlatform = formattedBuildMode(buildMode);

    project.flutterPluginSwiftPackageManifest.writeAsStringSync(
      manifestContents.replaceFirst(oldBuildMode, newSupportedPlatform),
    );
  }
}

enum DarwinPlatform {
  ios(
    name: 'ios',
    frameworkName: 'Flutter',
    targetPlatform: TargetPlatform.ios,
    packagePlatform: SwiftPackagePlatform.ios,
    artifactName: 'ios',
    artifactZip: 'artifacts.zip',
    xcframeworkArtifact: Artifact.flutterXcframework,
    sdks: <DarwinSDK>[DarwinSDK.iphoneos, DarwinSDK.iphonesimulator],
  ),
  macos(
    name: 'macos',
    frameworkName: 'FlutterMacOS',
    targetPlatform: TargetPlatform.darwin,
    packagePlatform: SwiftPackagePlatform.macos,
    artifactName: 'darwin-x64',
    artifactZip: 'framework.zip',
    xcframeworkArtifact: Artifact.flutterMacOSXcframework,
    sdks: <DarwinSDK>[DarwinSDK.macos],
  );

  const DarwinPlatform({
    required this.name,
    required this.frameworkName,
    required this.targetPlatform,
    required this.packagePlatform,
    required this.artifactName,
    required this.artifactZip,
    required this.xcframeworkArtifact,
    required this.sdks,
  });

  final String name;
  final String frameworkName;
  final TargetPlatform targetPlatform;
  final SwiftPackagePlatform packagePlatform;
  final String artifactName;
  final String artifactZip;
  final Artifact xcframeworkArtifact;
  final List<DarwinSDK> sdks;

  Version deploymentTarget() {
    switch (this) {
      case DarwinPlatform.ios:
        return Version(13, 0, null);
      case DarwinPlatform.macos:
        return Version(10, 15, null);
    }
  }

  SwiftPackageSupportedPlatform get supportedPackagePlatform {
    return SwiftPackageSupportedPlatform(platform: packagePlatform, version: deploymentTarget());
  }

  XcodeBasedProject xcodeProject(FlutterProject project) {
    switch (this) {
      case DarwinPlatform.ios:
        return project.ios;
      case DarwinPlatform.macos:
        return project.macos;
    }
  }
}

enum DarwinSDK {
  iphoneos(name: 'iphoneos', sdkType: EnvironmentType.physical),
  iphonesimulator(name: 'iphonesimulator', sdkType: EnvironmentType.simulator),
  macos(name: 'macosx');

  const DarwinSDK({required this.name, this.sdkType});

  final String name;
  final EnvironmentType? sdkType;
}
