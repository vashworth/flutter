// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import '../artifacts.dart';
import '../base/common.dart';
import '../base/error_handling_io.dart';
import '../base/file_system.dart';
import '../base/logger.dart';
import '../base/process.dart';
import '../base/template.dart';
import '../base/utils.dart';
import '../base/version.dart';
import '../build_info.dart';
import '../cache.dart';
import '../globals.dart' as globals;
import '../plugins.dart';
import '../project.dart';
import 'swift_packages.dart';

/// The name of the Swift package that's generated by the Flutter tool to add
/// dependencies on Flutter plugin swift packages.
const String kFlutterGeneratedPluginSwiftPackageName = 'FlutterGeneratedPluginSwiftPackage';

/// Swift Package Manager is a dependency management solution for iOS and macOS
/// applications.
///
/// See also:
///   * https://www.swift.org/documentation/package-manager/ - documentation on
///     Swift Package Manager.
///   * https://developer.apple.com/documentation/packagedescription/package -
///     documentation on Swift Package Manager manifest file, Package.swift.
class SwiftPackageManager {
  const SwiftPackageManager({
    required Artifacts artifacts,
    required Cache cache,
    required FileSystem fileSystem,
    required TemplateRenderer templateRenderer,
  }) : _artifacts = artifacts,
       _cache = cache,
       _fileSystem = fileSystem,
       _templateRenderer = templateRenderer;

  final Artifacts _artifacts;
  final Cache _cache;
  final FileSystem _fileSystem;
  final TemplateRenderer _templateRenderer;

  static final SwiftPackageSupportedPlatform iosSwiftPackageSupportedPlatform =
      SwiftPackageSupportedPlatform(
        platform: SwiftPackagePlatform.ios,
        version: Version(13, 0, null),
      );

  static final SwiftPackageSupportedPlatform macosSwiftPackageSupportedPlatform =
      SwiftPackageSupportedPlatform(
        platform: SwiftPackagePlatform.macos,
        version: Version(10, 15, null),
      );

  Future<void> generateFlutterSwiftPackages(
    DarwinPlatform platform,
    XcodeBasedProject xcodeProject,
    List<Plugin> plugins,
  ) async {
    final Directory symlinkDirectory = xcodeProject.relativeSwiftPackagesDirectory;
    ErrorHandlingFileSystem.deleteIfExists(symlinkDirectory, recursive: true);
    symlinkDirectory.createSync(recursive: true);

    await generateFlutterFrameworkSwiftPackage(platform, xcodeProject);
    await _generatePluginsSwiftPackage(plugins, platform, xcodeProject);
  }

  Future<void> generateFlutterFrameworkSwiftPackage(
    DarwinPlatform platform,
    XcodeBasedProject project, {
    BuildMode buildMode = BuildMode.release,
  }) async {
    await generateConditionalFlutterFrameworkSwiftPackage(
      project.parent,
      platforms: <DarwinPlatform>[platform],
      buildMode: buildMode,
      manifestPath: project.flutterFrameworkSwiftPackageManifest,
    );
  }

  /// Creates a Swift Package that vends the (symlinked) Flutter framework.
  Future<void> generateConditionalFlutterFrameworkSwiftPackage(
    FlutterProject project, {
    required List<DarwinPlatform> platforms,
    BuildMode buildMode = BuildMode.release,
    required File manifestPath,
    bool remoteFramework = false,
  }) async {
    final String engineVersion = _cache.engineRevision;
    final String buildModeName = sentenceCase(buildMode.cliName);

    final SwiftPackageProduct generatedProduct = SwiftPackageProduct(
      name: 'Flutter',
      targets: <String>['FlutterFramework'],
    );

    final List<SwiftPackageTargetDependency> targetDependencies = <SwiftPackageTargetDependency>[];
    final List<SwiftPackageTarget> binaryTargets = <SwiftPackageTarget>[];

    if (platforms.contains(DarwinPlatform.ios)) {
      final (
        SwiftPackageTargetDependency iosTargetDependencies,
        SwiftPackageTarget iosBinaryTarget,
      ) = await _createFrameworkDependency(
        project: project.ios,
        platform: DarwinPlatform.ios,
        buildMode: buildMode,
        buildModeName: buildModeName,
        engineVersion: engineVersion,
        remoteFramework: remoteFramework,
      );
      targetDependencies.add(iosTargetDependencies);
      binaryTargets.add(iosBinaryTarget);
    }
    if (platforms.contains(DarwinPlatform.macos)) {
      final (
        SwiftPackageTargetDependency macosTargetDependencies,
        SwiftPackageTarget macosBinaryTarget,
      ) = await _createFrameworkDependency(
        project: project.macos,
        platform: DarwinPlatform.macos,
        buildMode: buildMode,
        buildModeName: buildModeName,
        engineVersion: engineVersion,
        remoteFramework: remoteFramework,
      );
      targetDependencies.add(macosTargetDependencies);
      binaryTargets.add(macosBinaryTarget);
    }

    final SwiftPackage flutterFrameworkPackage = SwiftPackage(
      manifest: manifestPath,
      name: 'Flutter',
      swiftCodeBeforePackageDefinition: '''
let mode = "$buildModeName"
let engine = "$engineVersion"
''',
      platforms: <SwiftPackageSupportedPlatform>[],
      products: <SwiftPackageProduct>[generatedProduct],
      dependencies: <SwiftPackagePackageDependency>[],
      targets: <SwiftPackageTarget>[
        SwiftPackageTarget.defaultTarget(
          name: 'FlutterFramework',
          dependencies: targetDependencies,
        ),
        ...binaryTargets,
      ],
      templateRenderer: _templateRenderer,
    );
    flutterFrameworkPackage.createSwiftPackage();
  }

  Future<(SwiftPackageTargetDependency, SwiftPackageTarget)> _createFrameworkDependency({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required BuildMode buildMode,
    required String buildModeName,
    required String engineVersion,
    required bool remoteFramework,
  }) async {
    final String frameworkName = platform.frameworkName;
    final SwiftPackageTargetDependency frameworkTarget = SwiftPackageTargetDependency.target(
      name: frameworkName,
      platformCondition: <SwiftPackagePlatform>[platform.packagePlatform],
    );

    if (remoteFramework) {
      return (frameworkTarget, await _remoteFlutterFrameworkTarget(platform, buildMode));
    }

    final String frameworkArtifactPath;
    if (platform == DarwinPlatform.ios) {
      frameworkArtifactPath = _artifacts.getArtifactPath(
        Artifact.flutterXcframework,
        platform: TargetPlatform.ios,
        mode: buildMode,
      );
    } else {
      frameworkArtifactPath = _artifacts.getArtifactPath(
        Artifact.flutterMacOSXcframework,
        platform: TargetPlatform.darwin,
        mode: buildMode,
      );
    }
    final String xcframeworkName = '$frameworkName.xcframework';

    ErrorHandlingFileSystem.deleteIfExists(
      project.flutterFrameworkSwiftPackageDirectory.childDirectory(buildModeName),
      recursive: true,
    );
    final Link frameworkLink = _fileSystem.link(
      project.flutterFrameworkSwiftPackageDirectory
          .childDirectory(buildModeName)
          .childDirectory(engineVersion)
          .childDirectory(xcframeworkName)
          .path,
    );
    frameworkLink.createSync(frameworkArtifactPath, recursive: true);

    return (
      frameworkTarget,
      SwiftPackageTarget.binaryTarget(
        name: frameworkName,
        relativePath: '\\(mode)/\\(engine)/$xcframeworkName',
      ),
    );
  }

  Future<SwiftPackageTarget> _remoteFlutterFrameworkTarget(
    DarwinPlatform platform,
    BuildMode mode,
  ) async {
    final Status status = globals.logger.startProgress(
      'Downloading Flutter framework to calculate checksum...',
    );

    final String artifactName = platform.artifactName;
    final String artifactZip = platform.artifactZip;

    final String artifactsMode =
        mode == BuildMode.debug ? artifactName : '$artifactName-${mode.cliName}';
    final String frameworkArtifactUrl =
        '${_cache.storageBaseUrl}/flutter_infra_release/flutter/${_cache.engineRevision}/$artifactsMode/$artifactZip';
    final Directory destination = globals.fs.systemTempDirectory.createTempSync(
      'flutter_framework.',
    );
    await _cache.downloadArtifact(
      Uri.parse(frameworkArtifactUrl),
      destination.childFile(artifactZip),
      status,
    );
    status.stop();

    final RunResult results = await globals.processUtils.run(<String>[
      'swift',
      'package',
      'compute-checksum',
      destination.childFile(artifactZip).path,
    ]);
    if (results.exitCode != 0) {
      throwToolExit('Failed to get checksum for Flutter framework: ${results.stderr}');
    }

    return SwiftPackageTarget.remoteBinaryTarget(
      name: platform.frameworkName,
      zipUrl: frameworkArtifactUrl,
      zipChecksum: results.stdout.trim(),
    );
  }

  /// Creates a Swift Package called 'FlutterGeneratedPluginSwiftPackage' that
  /// has dependencies on Flutter plugins that are compatible with Swift
  /// Package Manager.
  Future<void> _generatePluginsSwiftPackage(
    List<Plugin> plugins,
    DarwinPlatform platform,
    XcodeBasedProject project,
  ) async {
    final Directory symlinkDirectory = project.relativeSwiftPackagesDirectory;

    final (
      List<SwiftPackagePackageDependency> packageDependencies,
      List<SwiftPackageTargetDependency> targetDependencies,
    ) = dependenciesForPlugins(
      plugins: plugins,
      platforms: <DarwinPlatform>[platform],
      fileSystem: _fileSystem,
      symlinkDirectory: symlinkDirectory,
      pathRelativeTo: project.flutterPluginSwiftPackageDirectory.path,
    );

    // If there aren't any Swift Package plugins and the project hasn't been
    // migrated yet, don't generate a Swift package or migrate the app since
    // it's not needed. If the project has already been migrated, regenerate
    // the Package.swift even if there are no dependencies in case there
    // were dependencies previously.
    if (packageDependencies.isEmpty && !project.flutterPluginSwiftPackageInProjectSettings) {
      return;
    }

    packageDependencies.add(
      SwiftPackagePackageDependency.local(
        packageName: 'FlutterFramework',
        localPath: _fileSystem.path.relative(
          project.flutterFrameworkSwiftPackageDirectory.path,
          from: project.flutterPluginSwiftPackageDirectory.path,
        ),
      ),
    );
    targetDependencies.add(
      SwiftPackageTargetDependency.product(name: 'Flutter', packageName: 'FlutterFramework'),
    );

    final SwiftPackageSupportedPlatform swiftSupportedPlatform;
    if (platform == DarwinPlatform.ios) {
      swiftSupportedPlatform = iosSwiftPackageSupportedPlatform;
    } else {
      swiftSupportedPlatform = macosSwiftPackageSupportedPlatform;
    }

    // FlutterGeneratedPluginSwiftPackage must be statically linked to ensure
    // any dynamic dependencies are linked to Runner and prevent undefined symbols.
    final SwiftPackageProduct generatedProduct = SwiftPackageProduct(
      name: kFlutterGeneratedPluginSwiftPackageName,
      targets: <String>[kFlutterGeneratedPluginSwiftPackageName],
      libraryType: SwiftPackageLibraryType.static,
    );

    final SwiftPackageTarget generatedTarget = SwiftPackageTarget.defaultTarget(
      name: kFlutterGeneratedPluginSwiftPackageName,
      dependencies: targetDependencies,
    );

    final SwiftPackage pluginsPackage = SwiftPackage(
      manifest: project.flutterPluginSwiftPackageManifest,
      name: kFlutterGeneratedPluginSwiftPackageName,
      platforms: <SwiftPackageSupportedPlatform>[swiftSupportedPlatform],
      products: <SwiftPackageProduct>[generatedProduct],
      dependencies: packageDependencies,
      targets: <SwiftPackageTarget>[generatedTarget],
      templateRenderer: _templateRenderer,
    );
    pluginsPackage.createSwiftPackage();
  }

  /// Generate a list of [SwiftPackagePackageDependency] and [SwiftPackageTargetDependency]
  /// from a list of [plugins] for the given [platform].
  static (List<SwiftPackagePackageDependency>, List<SwiftPackageTargetDependency>)
  dependenciesForPlugins({
    required List<Plugin> plugins,
    required List<DarwinPlatform> platforms,
    required FileSystem fileSystem,
    required Directory symlinkDirectory,
    required String pathRelativeTo,
  }) {
    final List<SwiftPackagePackageDependency> packageDependencies =
        <SwiftPackagePackageDependency>[];
    final List<SwiftPackageTargetDependency> targetDependencies = <SwiftPackageTargetDependency>[];

    for (final Plugin plugin in plugins) {
      final List<SwiftPackagePlatform> supportedPlatforms = <SwiftPackagePlatform>[];
      final Set<String> manifests = <String>{};
      bool isASwiftPackage = false;
      for (final DarwinPlatform platform in platforms) {
        // Skip plugin if it doesn't support iOS and/or macOS or doesn't have a Package.swift.
        final String? pluginSwiftPackageManifestPath = plugin.pluginSwiftPackageManifestPath(
          fileSystem,
          platform.name,
        );
        String? packagePath = plugin.pluginSwiftPackagePath(fileSystem, platform.name);
        if (plugin.platforms[platform.name] == null ||
            pluginSwiftPackageManifestPath == null ||
            packagePath == null ||
            !fileSystem.file(pluginSwiftPackageManifestPath).existsSync()) {
          continue;
        }
        isASwiftPackage = true;

        supportedPlatforms.add(platform.packagePlatform);
        if (manifests.contains(pluginSwiftPackageManifestPath)) {
          continue;
        }

        manifests.add(pluginSwiftPackageManifestPath);
        final Link pluginSymlink = symlinkDirectory.childLink(plugin.name);
        ErrorHandlingFileSystem.deleteIfExists(pluginSymlink);
        pluginSymlink.createSync(packagePath);
        packagePath = pluginSymlink.path;
        packagePath = fileSystem.path.relative(packagePath, from: pathRelativeTo);

        packageDependencies.add(
          SwiftPackagePackageDependency.local(packageName: plugin.name, localPath: packagePath),
        );
      }
      if (isASwiftPackage) {
        // The target dependency product name is hyphen separated because it's
        // the dependency's library name, which Swift Package Manager will
        // automatically use as the CFBundleIdentifier if linked dynamically. The
        // CFBundleIdentifier cannot contain underscores.
        targetDependencies.add(
          SwiftPackageTargetDependency.product(
            name: plugin.name.replaceAll('_', '-'),
            packageName: plugin.name,
            platformCondition: (platforms.length > 1) ? supportedPlatforms : null,
          ),
        );
      }
    }
    return (packageDependencies, targetDependencies);
  }

  /// If the project's IPHONEOS_DEPLOYMENT_TARGET/MACOSX_DEPLOYMENT_TARGET is
  /// higher than the FlutterGeneratedPluginSwiftPackage's default
  /// DarwinPlatform, increase the DarwinPlatform to match the project's
  /// deployment target.
  ///
  /// This is done for the use case of a plugin requiring a higher iOS/macOS
  /// version than FlutterGeneratedPluginSwiftPackage.
  ///
  /// Swift Package Manager emits an error if a dependency isn’t compatible
  /// with the top-level package’s deployment version. The deployment target of
  /// a package’s dependencies must be lower than or equal to the top-level
  /// package’s deployment target version for a particular platform.
  ///
  /// To still be able to use the plugin, the user can increase the Xcode
  /// project's iOS/macOS deployment target and this will then increase the
  /// deployment target for FlutterGeneratedPluginSwiftPackage.
  static void updateMinimumDeployment({
    required XcodeBasedProject project,
    required DarwinPlatform platform,
    required String deploymentTarget,
  }) {
    final Version? projectDeploymentTargetVersion = Version.parse(deploymentTarget);
    final SwiftPackageSupportedPlatform defaultPlatform;
    final SwiftPackagePlatform packagePlatform = platform.packagePlatform;
    if (platform == DarwinPlatform.ios) {
      defaultPlatform = iosSwiftPackageSupportedPlatform;
    } else {
      defaultPlatform = macosSwiftPackageSupportedPlatform;
    }

    if (projectDeploymentTargetVersion == null ||
        projectDeploymentTargetVersion <= defaultPlatform.version ||
        !project.flutterPluginSwiftPackageManifest.existsSync()) {
      return;
    }

    final String manifestContents = project.flutterPluginSwiftPackageManifest.readAsStringSync();
    final String oldDarwinPlatform = defaultPlatform.format();
    final String newDarwinPlatform =
        SwiftPackageSupportedPlatform(
          platform: packagePlatform,
          version: projectDeploymentTargetVersion,
        ).format();

    project.flutterPluginSwiftPackageManifest.writeAsStringSync(
      manifestContents.replaceFirst(oldDarwinPlatform, newDarwinPlatform),
    );
  }
}

enum DarwinPlatform {
  ios(
    name: 'ios',
    frameworkName: 'Flutter',
    targetPlatform: TargetPlatform.ios,
    packagePlatform: SwiftPackagePlatform.ios,
    artifactName: 'ios',
    artifactZip: 'artifacts.zip',
    xcframeworkArtifact: Artifact.flutterXcframework,
    sdks: <DarwinSDK>[DarwinSDK.iphoneos, DarwinSDK.iphonesimulator],
  ),
  macos(
    name: 'macos',
    frameworkName: 'FlutterMacOS',
    targetPlatform: TargetPlatform.darwin,
    packagePlatform: SwiftPackagePlatform.macos,
    artifactName: 'darwin-x64',
    artifactZip: 'framework.zip',
    xcframeworkArtifact: Artifact.flutterMacOSXcframework,
    sdks: <DarwinSDK>[DarwinSDK.macos],
  );

  const DarwinPlatform({
    required this.name,
    required this.frameworkName,
    required this.targetPlatform,
    required this.packagePlatform,
    required this.artifactName,
    required this.artifactZip,
    required this.xcframeworkArtifact,
    required this.sdks,
  });

  final String name;
  final String frameworkName;
  final TargetPlatform targetPlatform;
  final SwiftPackagePlatform packagePlatform;
  final String artifactName;
  final String artifactZip;
  final Artifact xcframeworkArtifact;
  final List<DarwinSDK> sdks;

  XcodeBasedProject xcodeProject(FlutterProject project) {
    switch (this) {
      case DarwinPlatform.ios:
        return project.ios;
      case DarwinPlatform.macos:
        return project.macos;
    }
  }
}

enum DarwinSDK {
  iphoneos(name: 'iphoneos', sdkType: EnvironmentType.physical),
  iphonesimulator(name: 'iphonesimulator', sdkType: EnvironmentType.simulator),
  macos(name: 'macosx');

  const DarwinSDK({required this.name, this.sdkType});

  final String name;
  final EnvironmentType? sdkType;
}
